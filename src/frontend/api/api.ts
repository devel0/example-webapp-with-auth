/* tslint:disable */
/* eslint-disable */
/**
 * ExampleWebApp API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AccessTokenNfo {
    'accessToken'?: string | null;
    'expiration'?: string;
}
export interface AuthOptions {
    'username': UsernameAuthOptions;
    'password': PasswordAuthOptions;
}
/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.CurrentUser api response data.
 */
export interface CurrentUserResponseDto {
    'status': CurrentUserStatus;
    /**
     * Login username.
     */
    'userName'?: string | null;
    /**
     * Email address.
     */
    'email'?: string | null;
    /**
     * List of roles associated to this user.
     */
    'roles'?: Set<string> | null;
    /**
     * Permissions related to this user roles.
     */
    'permissions'?: Set<UserPermission> | null;
}


/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.CurrentUser response api specific status.  OK (Authentication valid.)  InvalidAuthentication (Invalid authentication.)  InvalidArgument (Invalid argument.)  AccessTokenNotFound (Access token not found.)
 */

export const CurrentUserStatus = {
    /**
    * Authentication valid.
    */
    OK: 'OK',
    /**
    * Invalid authentication.
    */
    InvalidAuthentication: 'InvalidAuthentication',
    /**
    * Invalid argument.
    */
    InvalidArgument: 'InvalidArgument',
    /**
    * Access token not found.
    */
    AccessTokenNotFound: 'AccessTokenNotFound'
} as const;

export type CurrentUserStatus = typeof CurrentUserStatus[keyof typeof CurrentUserStatus];


export interface DeleteUserRequestDto {
    'usernameToDelete': string;
}
export interface DeleteUserResponseDto {
    'status': DeleteUserStatus;
    /**
     * List of edit user errors if any.
     */
    'errors'?: Array<string> | null;
}


/**
 *   OK (Delete user ok.)  IdentityError (asp net core IdentityError, see Errors for details.)  UserNotFound (User not found.)  CannotDeleteLastActiveAdmin (Cannot delete last non disabled admin user.)  PermissionsError
 */

export const DeleteUserStatus = {
    /**
    * Delete user ok.
    */
    OK: 'OK',
    /**
    * asp net core IdentityError, see Errors for details.
    */
    IdentityError: 'IdentityError',
    /**
    * User not found.
    */
    UserNotFound: 'UserNotFound',
    /**
    * Cannot delete last non disabled admin user.
    */
    CannotDeleteLastActiveAdmin: 'CannotDeleteLastActiveAdmin',
    /**
    * 
    */
    PermissionsError: 'PermissionsError'
} as const;

export type DeleteUserStatus = typeof DeleteUserStatus[keyof typeof DeleteUserStatus];


/**
 * Edit user data
 */
export interface EditUserRequestDto {
    /**
     * Existing User name or null to create a new one using ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.EditUserRequestDto.EditUsername.
     */
    'existingUsername'?: string | null;
    /**
     * New email or null to leave unchanged.
     */
    'editEmail'?: string | null;
    /**
     * New username or null to leave unchanged.
     */
    'editUsername'?: string | null;
    /**
     * New password or null to leave unchanged.
     */
    'editPassword'?: string | null;
    /**
     * Roles to set to the user or null to leave unchanged.
     */
    'editRoles'?: Array<string> | null;
    /**
     * If true the user can\'t login after previous release access token expires.
     */
    'editDisabled'?: boolean | null;
    /**
     * Set the end date of lockout. The user will be unable to login until ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.EditUserRequestDto.EditLockoutEnd. If ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.EditUserRequestDto.EditLockoutEnd is set in the past the user will be re-enabled immediately.
     */
    'editLockoutEnd'?: string | null;
}
export interface EditUserResponseDto {
    'status': EditUserStatus;
    /**
     * Roles added.
     */
    'rolesAdded'?: Array<string> | null;
    /**
     * Roles removed.
     */
    'rolesRemoved'?: Array<string> | null;
    /**
     * List of edit user errors if any.
     */
    'errors'?: Array<string> | null;
}


/**
 *   OK (Edit user ok.)  IdentityError (asp net core IdentityError, see Errors for details.)  CannotChangeUsername (Username cannot be changed.)  UserNotFound (User not found.)  PermissionsError
 */

export const EditUserStatus = {
    /**
    * Edit user ok.
    */
    OK: 'OK',
    /**
    * asp net core IdentityError, see Errors for details.
    */
    IdentityError: 'IdentityError',
    /**
    * Username cannot be changed.
    */
    CannotChangeUsername: 'CannotChangeUsername',
    /**
    * User not found.
    */
    UserNotFound: 'UserNotFound',
    /**
    * 
    */
    PermissionsError: 'PermissionsError'
} as const;

export type EditUserStatus = typeof EditUserStatus[keyof typeof EditUserStatus];


/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.Login(ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.LoginRequestDto) api request data.
 */
export interface LoginRequestDto {
    /**
     * Username or email.
     */
    'usernameOrEmail'?: string | null;
    /**
     * Password.
     */
    'password': string;
    'passwordResetToken'?: string | null;
}
/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.Login(ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.LoginRequestDto) api response data.
 */
export interface LoginResponseDto {
    'status': LoginStatus;
    /**
     * Username.
     */
    'userName'?: string | null;
    /**
     * Email.
     */
    'email'?: string | null;
    /**
     * User roles.
     */
    'roles'?: Array<string> | null;
    'errors'?: Array<string> | null;
    /**
     * Permissions related to this user roles.
     */
    'permissions'?: Set<UserPermission> | null;
    /**
     * Expiration timestamp for the refresh token. To keep alive auth issue M:ExampleWebApp.Backend.WebApi.AuthController.RenewRefreshToken before  token expire.
     */
    'refreshTokenExpiration'?: string;
}


/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.Login(ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.LoginRequestDto) response api specific status.  OK (Login vaild.)  UsernameOrEmailRequired (Missing username or email.)  InvalidAuthentication (Invalid authentication.)  InvalidHttpContext (Authentication http context.)
 */

export const LoginStatus = {
    /**
    * Login vaild.
    */
    OK: 'OK',
    /**
    * Missing username or email.
    */
    UsernameOrEmailRequired: 'UsernameOrEmailRequired',
    /**
    * Invalid authentication.
    */
    InvalidAuthentication: 'InvalidAuthentication',
    /**
    * Authentication http context.
    */
    InvalidHttpContext: 'InvalidHttpContext'
} as const;

export type LoginStatus = typeof LoginStatus[keyof typeof LoginStatus];


export interface PasswordAuthOptions {
    'requireDigit': boolean;
    'requiredLength': number;
    'requiredUniqueChars': number;
    'requireLowercase': boolean;
    'requireNonAlphanumeric': boolean;
    'requireUppercase': boolean;
}
export interface RefreshTokenNfo {
    'refreshToken'?: string | null;
    'expiration'?: string;
}
/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.RenewAccessToken api response data.
 */
export interface RenewAccessTokenResponse {
    'status': RenewAccessTokenStatus;
    'accessTokenNfo'?: AccessTokenNfo;
}


/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.RenewAccessToken response api specific status.  OK (Valid refresh token, thus access token renewd.)  InvalidAuthentication (Invalid authentication.)  InvalidAccessToken (Invalid access token.)  InvalidRefreshToken (Invalid refresh token.)  InvalidHttpContext (Invalid http context.)
 */

export const RenewAccessTokenStatus = {
    /**
    * Valid refresh token, thus access token renewd.
    */
    OK: 'OK',
    /**
    * Invalid authentication.
    */
    InvalidAuthentication: 'InvalidAuthentication',
    /**
    * Invalid access token.
    */
    InvalidAccessToken: 'InvalidAccessToken',
    /**
    * Invalid refresh token.
    */
    InvalidRefreshToken: 'InvalidRefreshToken',
    /**
    * Invalid http context.
    */
    InvalidHttpContext: 'InvalidHttpContext'
} as const;

export type RenewAccessTokenStatus = typeof RenewAccessTokenStatus[keyof typeof RenewAccessTokenStatus];


/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.RenewRefreshToken api response data.
 */
export interface RenewRefreshTokenResponse {
    'status': RenewRefreshTokenStatus;
    'refreshTokenNfo'?: RefreshTokenNfo;
}


/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.RenewRefreshToken response api specific status.  OK (Authentication valid.)  InvalidAuthentication (Invalid authentication.)  InvalidHttpContext (Invalid http context.)  AccessTokenNotFound (Access token not found.)  InvalidRefreshToken (Invalid refresh token.)
 */

export const RenewRefreshTokenStatus = {
    /**
    * Authentication valid.
    */
    OK: 'OK',
    /**
    * Invalid authentication.
    */
    InvalidAuthentication: 'InvalidAuthentication',
    /**
    * Invalid http context.
    */
    InvalidHttpContext: 'InvalidHttpContext',
    /**
    * Access token not found.
    */
    AccessTokenNotFound: 'AccessTokenNotFound',
    /**
    * Invalid refresh token.
    */
    InvalidRefreshToken: 'InvalidRefreshToken'
} as const;

export type RenewRefreshTokenStatus = typeof RenewRefreshTokenStatus[keyof typeof RenewRefreshTokenStatus];


/**
 * M:ExampleWebApp.Backend.WebApi.AuthController.ListUsers(System.String) api response data.
 */
export interface UserListItemResponseDto {
    /**
     * User name.
     */
    'userName': string;
    /**
     * User email.
     */
    'email': string;
    /**
     * User roles.
     */
    'roles': Array<string>;
    'disabled': boolean;
    /**
     * Access failed count.
     */
    'accessFailedCount': number;
    /**
     * Email is confirmed.
     */
    'emailConfirmed': boolean;
    /**
     * Lockout end (UTC). ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.UserListItemResponseDto.LockoutEnabled.
     */
    'lockoutEnd': string;
    /**
     * If true the user is lockout until ExampleWebApp.Backend.WebApi.Services.Abstractions.Auth.DTOs.UserListItemResponseDto.LockoutEnd.
     */
    'lockoutEnabled': boolean;
    /**
     * User phone number.
     */
    'phoneNumber': string;
    /**
     * User phone number confirmed.
     */
    'phoneNumberConfirmed': boolean;
    /**
     * Two factor enabled.
     */
    'twoFactorEnabled': boolean;
}
/**
 *   ChangeUserRoles (Change another user roles.)  CreateAdminUser (Can create another user with \"admin\" role.)  CreateAdvancedUser (Can create another user with \"advanced\" role.)  CreateNormalUser (Can create another user with \"normal\" role.)  ChangeOwnEmail (Change its own email (without need to validate).)  ChangeOwnPassword (Change its own password (by reset).)  ChangeNormalUserEmail (Change email of another user which max role is \"normal\".)  ChangeAdvancedUserEmail (Change email of another user which max role is \"advanced\".)  ChangeAdminUserEmail (Change email of another user which max role is \"admin\".)  ResetNormalUserPassword (Reset password of another user which max role is \"normal\".)  ResetAdvancedUserPassword (Reset password of another user which max role is \"advanced\".)  ResetAdminUserPassword (Reset password of another user which max role is \"normal\".)  LockoutAdminUser (Edit lockout of another user which max role is \"admin\".)  LockoutAdvancedUser (Edit lockout of another user which max role is \"advanced\".)  LockoutNormalUser (Edit lockout of another user which max role is \"normal\".)  DeleteAdminUser (Delete user which max role is \"admin\".)  DeleteAdvancedUser (Delete user which max role is \"advanced\".)  DeleteNormalUser (Delete user which max role is \"normal\".)  DisableAdminUser (Disable user which max role is \"admin\".)  DisableAdvancedUser (Disable user which max role is \"advanced\".)  DisableNormalUser (Disable user which max role is \"normal\".)  ResetLostPassword (Generate an email with a reset password token.)
 */

export const UserPermission = {
    /**
    * Change another user roles.
    */
    ChangeUserRoles: 'ChangeUserRoles',
    /**
    * Can create another user with &quot;admin&quot; role.
    */
    CreateAdminUser: 'CreateAdminUser',
    /**
    * Can create another user with &quot;advanced&quot; role.
    */
    CreateAdvancedUser: 'CreateAdvancedUser',
    /**
    * Can create another user with &quot;normal&quot; role.
    */
    CreateNormalUser: 'CreateNormalUser',
    /**
    * Change its own email (without need to validate).
    */
    ChangeOwnEmail: 'ChangeOwnEmail',
    /**
    * Change its own password (by reset).
    */
    ChangeOwnPassword: 'ChangeOwnPassword',
    /**
    * Change email of another user which max role is &quot;normal&quot;.
    */
    ChangeNormalUserEmail: 'ChangeNormalUserEmail',
    /**
    * Change email of another user which max role is &quot;advanced&quot;.
    */
    ChangeAdvancedUserEmail: 'ChangeAdvancedUserEmail',
    /**
    * Change email of another user which max role is &quot;admin&quot;.
    */
    ChangeAdminUserEmail: 'ChangeAdminUserEmail',
    /**
    * Reset password of another user which max role is &quot;normal&quot;.
    */
    ResetNormalUserPassword: 'ResetNormalUserPassword',
    /**
    * Reset password of another user which max role is &quot;advanced&quot;.
    */
    ResetAdvancedUserPassword: 'ResetAdvancedUserPassword',
    /**
    * Reset password of another user which max role is &quot;normal&quot;.
    */
    ResetAdminUserPassword: 'ResetAdminUserPassword',
    /**
    * Edit lockout of another user which max role is &quot;admin&quot;.
    */
    LockoutAdminUser: 'LockoutAdminUser',
    /**
    * Edit lockout of another user which max role is &quot;advanced&quot;.
    */
    LockoutAdvancedUser: 'LockoutAdvancedUser',
    /**
    * Edit lockout of another user which max role is &quot;normal&quot;.
    */
    LockoutNormalUser: 'LockoutNormalUser',
    /**
    * Delete user which max role is &quot;admin&quot;.
    */
    DeleteAdminUser: 'DeleteAdminUser',
    /**
    * Delete user which max role is &quot;advanced&quot;.
    */
    DeleteAdvancedUser: 'DeleteAdvancedUser',
    /**
    * Delete user which max role is &quot;normal&quot;.
    */
    DeleteNormalUser: 'DeleteNormalUser',
    /**
    * Disable user which max role is &quot;admin&quot;.
    */
    DisableAdminUser: 'DisableAdminUser',
    /**
    * Disable user which max role is &quot;advanced&quot;.
    */
    DisableAdvancedUser: 'DisableAdvancedUser',
    /**
    * Disable user which max role is &quot;normal&quot;.
    */
    DisableNormalUser: 'DisableNormalUser',
    /**
    * Generate an email with a reset password token.
    */
    ResetLostPassword: 'ResetLostPassword'
} as const;

export type UserPermission = typeof UserPermission[keyof typeof UserPermission];


export interface UsernameAuthOptions {
    'allowedUserNameCharacters': string;
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve auth options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthAuthOptionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/AuthOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current logged in user name, email, roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthCurrentUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/CurrentUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user.
         * @param {DeleteUserRequestDto} [deleteUserRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthDeleteUserPost: async (deleteUserRequestDto?: DeleteUserRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/DeleteUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit user data
         * @param {EditUserRequestDto} [editUserRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthEditUserPost: async (editUserRequestDto?: EditUserRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/EditUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editUserRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthListRolesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/ListRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users or specific if param given.
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthListUsersGet: async (username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/ListUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login user by given username or email and auth password.
         * @param {LoginRequestDto} [loginRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost: async (loginRequestDto?: LoginRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRenewAccessTokenPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/RenewAccessToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renew refresh token of current user if refresh token still valid. This is used to extends refresh token duration avoiding closing frontend session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRenewRefreshTokenPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/RenewRefreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset lost password.
         * @param {string} [email] 
         * @param {string} [token] 
         * @param {string} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResetLostPasswordGet: async (email?: string, token?: string, resetPassword?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Auth/ResetLostPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (resetPassword !== undefined) {
                localVarQueryParameter['resetPassword'] = resetPassword;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve auth options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthAuthOptionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthAuthOptionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthAuthOptionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve current logged in user name, email, roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthCurrentUserGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthCurrentUserGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthCurrentUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete user.
         * @param {DeleteUserRequestDto} [deleteUserRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthDeleteUserPost(deleteUserRequestDto?: DeleteUserRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthDeleteUserPost(deleteUserRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthDeleteUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit user data
         * @param {EditUserRequestDto} [editUserRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthEditUserPost(editUserRequestDto?: EditUserRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditUserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthEditUserPost(editUserRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthEditUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthListRolesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthListRolesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthListRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all users or specific if param given.
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthListUsersGet(username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserListItemResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthListUsersGet(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthListUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login user by given username or email and auth password.
         * @param {LoginRequestDto} [loginRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLoginPost(loginRequestDto?: LoginRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLoginPost(loginRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLogoutGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLogoutGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthLogoutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthRenewAccessTokenPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RenewAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthRenewAccessTokenPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthRenewAccessTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Renew refresh token of current user if refresh token still valid. This is used to extends refresh token duration avoiding closing frontend session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthRenewRefreshTokenPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RenewRefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthRenewRefreshTokenPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthRenewRefreshTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset lost password.
         * @param {string} [email] 
         * @param {string} [token] 
         * @param {string} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthResetLostPasswordGet(email?: string, token?: string, resetPassword?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthResetLostPasswordGet(email, token, resetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthResetLostPasswordGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve auth options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthAuthOptionsGet(options?: RawAxiosRequestConfig): AxiosPromise<AuthOptions> {
            return localVarFp.apiAuthAuthOptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve current logged in user name, email, roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthCurrentUserGet(options?: RawAxiosRequestConfig): AxiosPromise<CurrentUserResponseDto> {
            return localVarFp.apiAuthCurrentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user.
         * @param {DeleteUserRequestDto} [deleteUserRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthDeleteUserPost(deleteUserRequestDto?: DeleteUserRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUserResponseDto> {
            return localVarFp.apiAuthDeleteUserPost(deleteUserRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit user data
         * @param {EditUserRequestDto} [editUserRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthEditUserPost(editUserRequestDto?: EditUserRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EditUserResponseDto> {
            return localVarFp.apiAuthEditUserPost(editUserRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthListRolesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.apiAuthListRolesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users or specific if param given.
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthListUsersGet(username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserListItemResponseDto>> {
            return localVarFp.apiAuthListUsersGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login user by given username or email and auth password.
         * @param {LoginRequestDto} [loginRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost(loginRequestDto?: LoginRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDto> {
            return localVarFp.apiAuthLoginPost(loginRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRenewAccessTokenPost(options?: RawAxiosRequestConfig): AxiosPromise<RenewAccessTokenResponse> {
            return localVarFp.apiAuthRenewAccessTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renew refresh token of current user if refresh token still valid. This is used to extends refresh token duration avoiding closing frontend session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRenewRefreshTokenPost(options?: RawAxiosRequestConfig): AxiosPromise<RenewRefreshTokenResponse> {
            return localVarFp.apiAuthRenewRefreshTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset lost password.
         * @param {string} [email] 
         * @param {string} [token] 
         * @param {string} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResetLostPasswordGet(email?: string, token?: string, resetPassword?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthResetLostPasswordGet(email, token, resetPassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve auth options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthAuthOptionsGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthAuthOptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve current logged in user name, email, roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthCurrentUserGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthCurrentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user.
     * @param {DeleteUserRequestDto} [deleteUserRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthDeleteUserPost(deleteUserRequestDto?: DeleteUserRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthDeleteUserPost(deleteUserRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit user data
     * @param {EditUserRequestDto} [editUserRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthEditUserPost(editUserRequestDto?: EditUserRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthEditUserPost(editUserRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthListRolesGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthListRolesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users or specific if param given.
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthListUsersGet(username?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthListUsersGet(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login user by given username or email and auth password.
     * @param {LoginRequestDto} [loginRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthLoginPost(loginRequestDto?: LoginRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLoginPost(loginRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthLogoutGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthRenewAccessTokenPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthRenewAccessTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renew refresh token of current user if refresh token still valid. This is used to extends refresh token duration avoiding closing frontend session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthRenewRefreshTokenPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthRenewRefreshTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset lost password.
     * @param {string} [email] 
     * @param {string} [token] 
     * @param {string} [resetPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthResetLostPasswordGet(email?: string, token?: string, resetPassword?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthResetLostPasswordGet(email, token, resetPassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MainApi - axios parameter creator
 */
export const MainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Long running api test. ( admin and users allowed )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMainLongRunningGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Main/LongRunning`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate test exception. ( only admin )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMainTestExceptionGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Main/TestException`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MainApi - functional programming interface
 */
export const MainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Long running api test. ( admin and users allowed )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMainLongRunningGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMainLongRunningGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainApi.apiMainLongRunningGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate test exception. ( only admin )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMainTestExceptionGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMainTestExceptionGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainApi.apiMainTestExceptionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MainApi - factory interface
 */
export const MainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MainApiFp(configuration)
    return {
        /**
         * 
         * @summary Long running api test. ( admin and users allowed )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMainLongRunningGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiMainLongRunningGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate test exception. ( only admin )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMainTestExceptionGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiMainTestExceptionGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MainApi - object-oriented interface
 */
export class MainApi extends BaseAPI {
    /**
     * 
     * @summary Long running api test. ( admin and users allowed )
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiMainLongRunningGet(options?: RawAxiosRequestConfig) {
        return MainApiFp(this.configuration).apiMainLongRunningGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate test exception. ( only admin )
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiMainTestExceptionGet(options?: RawAxiosRequestConfig) {
        return MainApiFp(this.configuration).apiMainTestExceptionGet(options).then((request) => request(this.axios, this.basePath));
    }
}



